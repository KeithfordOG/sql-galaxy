import streamlit as st
import pandas as pd
import sqlparse
import psycopg2
from urllib.parse import urlparse
from datetime import datetime, timedelta

# PostgreSQL Database connection function
def create_connection():
    try:
        # Retrieve the database URL from Streamlit secrets
        url = st.secrets["postgresql"]["DB_URL"]
        
        # Parse the URL to extract connection parameters
        parsed_url = urlparse(url)
        
        # Connect to the PostgreSQL database
        conn = psycopg2.connect(
            host=parsed_url.hostname,
            database=parsed_url.path[1:],  # Remove leading '/'
            user=parsed_url.username,
            password=parsed_url.password,
            port=parsed_url.port
        )
        return conn
    except Exception as e:
        st.error(f"Error connecting to the database: {e}")
        return None

# Function to execute SQL query and return result as a Pandas DataFrame
def execute_sql_query(query):
    conn = create_connection()
    if conn:
        try:
            cur = conn.cursor()
            cur.execute(query)
            columns = [desc[0] for desc in cur.description]  # Get column names
            result = cur.fetchall()  # Fetch all rows
            cur.close()
            conn.close()
            if not result:
                st.warning("The query executed but returned no results.")
            return pd.DataFrame(result, columns=columns)  # Return result as a DataFrame
        except Exception as e:
            st.error(f"Error executing query: {e}")
            return None
    else:
        return None

# Function to normalize and format SQL query
def normalize_sql(query):
    return sqlparse.format(query, reindent=True, keyword_case='upper').strip()

# Initialize session state to track correctness for Milky Way and timing
if 'answer_correct_milkyway' not in st.session_state:
    st.session_state.answer_correct_milkyway = [False] * 5
if 'questions_completed' not in st.session_state:
    st.session_state.questions_completed = 0
if 'timing_enabled' not in st.session_state:
    st.session_state.timing_enabled = False
if 'start_time' not in st.session_state:
    st.session_state.start_time = None
if 'end_time' not in st.session_state:
    st.session_state.end_time = None
if 'user_name' not in st.session_state:
    st.session_state.user_name = ""
if 'time_remaining' not in st.session_state:
    st.session_state.time_remaining = timedelta(minutes=10)  # Start with 10 minutes

# Title and Image at the top
st.title('BEGINNER')
st.image("images/milkyway.png", "*Milky Way (Galaxy) *Generated by ChatGPT4", use_column_width=True)

# Timer display above the tabs
timer_placeholder = st.empty()  # Placeholder to display the countdown timer

# Adding a new "Introduction" tab for greeting and table information
tabs = st.tabs(["Introduction"] + [f"Question {i+1}" for i in range(5)] + ["Results"])

# Function to handle countdown
def countdown():
    if st.session_state.timing_enabled and st.session_state.start_time:
        # Calculate time remaining
        elapsed_time = datetime.now() - st.session_state.start_time
        st.session_state.time_remaining = timedelta(minutes=10) - elapsed_time

        # Stop the timer if time runs out
        if st.session_state.time_remaining <= timedelta(0):
            st.session_state.time_remaining = timedelta(0)
            st.session_state.timing_enabled = False
            st.error("Time is up!")
        
        # Update the countdown display
        minutes, seconds = divmod(st.session_state.time_remaining.seconds, 60)
        timer_placeholder.markdown(f"### **Time Remaining:** {minutes} minutes {seconds} seconds")
    else:
        timer_placeholder.markdown("### **Timer:** Not started")

# Call the countdown function to update the timer
countdown()

# Introduction tab (first tab)
with tabs[0]:
    st.title("Welcome to SQL Galaxy - Beginner Section ðŸŒŒ")
    
    # Emphasize inputting user name before starting
    st.markdown("""
    **Please enter your name to begin!**  
    Your name is required to track your progress and display your results.  
    Once you have entered your name, you can start the countdown timer and begin answering the questions.
    """)

    # Input for user's name
    st.session_state.user_name = st.text_input("Enter your name:", key="name_input")

    # Only show the Start Timer button after the name is entered
    if st.session_state.user_name:
        if st.button("Start Countdown to Begin"):
            st.session_state.timing_enabled = True
            st.session_state.start_time = datetime.now()
            st.experimental_rerun()  # Rerun to ensure the countdown starts

# Questions and answers
questions = [
    "Retrieve all records from the planets table.",
    "How would you count the number of missions in the missions table?",
    "What is the SQL query to find the discoverer of the planet Venus?",
    "Write a SQL query to retrieve all missions after the year 2000.",
    "Write a SQL query to return all the moons that start with the letter 'C'."
]

correct_answers = [
    [
        "SELECT * FROM planets;",  # Basic SELECT *
        "SELECT planet_id, planet_name, distance_from_sun, discoverer FROM planets;",  # With explicit columns
    ],
    [
        "SELECT COUNT(*) FROM missions;",  # Counting rows in the missions table
    ],
    [
        "SELECT discoverer FROM planets WHERE planet_name = 'Venus';",  # Using planet name
        "SELECT discoverer FROM planets WHERE planet_id = 6;",  # Using planet ID
    ],
    [
        "SELECT * FROM missions WHERE mission_date > '2000-01-01';",  # Basic query with date comparison
        "SELECT * FROM missions WHERE EXTRACT(YEAR FROM mission_date) > 2000;",  # Using EXTRACT for year comparison
    ],
    [
        "SELECT * FROM moons WHERE moon_name LIKE 'C%';",  # Using LIKE to filter names starting with 'C'
        "SELECT * FROM moons WHERE moon_name ILIKE 'C%';",  # Using ILIKE for case-insensitive search (PostgreSQL-specific)
    ]
]

# Loop through each question and set up a tab
for i, query in enumerate(questions):
    with tabs[i+1]:
        st.title(f"Question {i+1} âœ¨")
        st.write(query)

        # Use text_area for multi-line input
        user_answer = st.text_area(f"Your Answer for Question {i+1}", key=f"milkyway_answer_{i}")

        # Hint section
        with st.expander("Need a hint?"):
            if i == 0:
                st.write("Use `SELECT * FROM` to retrieve all columns from a table, or explicitly list column names if desired.")
            elif i == 1:
                st.write("Use `COUNT(*)` to count the number of rows in the missions table.")
            elif i == 2:
                st.write("You can filter by `planet_name = 'Venus'` or `planet_id = 6`.")
            elif i == 3:
                st.write("Use `WHERE mission_date > '2000-01-01'` or `EXTRACT(YEAR FROM mission_date) > 2000`.")
            elif i == 4:
                st.write("Use `LIKE 'C%'` to find moons starting with 'C', or `ILIKE 'C%'` for case-insensitive search in PostgreSQL.")

        # Submit button for each question
        if st.button(f"Submit Answer for Question {i+1}", key=f"submit_milkyway_{i}"):
            # Normalize user's answer and correct answers
            normalized_user_answer = normalize_sql(user_answer)
            normalized_correct_answers = [normalize_sql(answer) for answer in correct_answers[i]]

            # Always run the user's query and show the result (even if it's wrong)
            st.write(f"Your Attempted Query: \n```sql\n{user_answer}\n```")
            try:
                query_result = execute_sql_query(user_answer)  # Execute the user's SQL query
                if query_result is not None and not query_result.empty:
                    st.dataframe(query_result)  # Show the SQL query result as a table
                else:
                    st.error("No data returned from the query.")
            except Exception as e:
                st.error(f"Error running query: {e}")

            # Check if the user's answer matches any normalized correct solutions
            if normalized_user_answer in normalized_correct_answers:
                if not st.session_state.answer_correct_milkyway[i]:  # Ensure it's the first time this question is correct
                    st.session_state.questions_completed += 1  # Increment completed count only once
                    st.session_state.answer_correct_milkyway[i] = True
                st.success("Great job! That's correct.")
            else:
                st.error("Incorrect answer. Please try again.")

        # Display the correct answer if the user has answered correctly
        if st.session_state.answer_correct_milkyway[i]:
            st.write(f"You've answered Question {i+1} correctly.")

# Function to save results to leaderboard
def save_to_leaderboard(user_name, completion_time, section):
    conn = create_connection()
    if conn:
        try:
            # Convert timedelta (completion_time) to a string in 'hh:mm:ss' format
            completion_time_str = str(completion_time)
            
            cur = conn.cursor()
            cur.execute("""
                INSERT INTO leaderboard (user_name, completion_time, section)
                VALUES (%s, %s, %s);
            """, (user_name, completion_time_str, section))
            conn.commit()
            cur.close()
            conn.close()
            st.success("Your result has been added to the leaderboard!")
        except Exception as e:
            st.error(f"Error saving to leaderboard: {e}")
    else:
        st.error("Failed to connect to the database.")

# Results Tab
with tabs[-1]:
    st.title("Results ðŸš€")

    # End the timer when all questions are completed
    if st.session_state.questions_completed == len(st.session_state.answer_correct_milkyway):
        if st.session_state.end_time is None:
            st.session_state.end_time = datetime.now()

        # Calculate the total time taken (end_time - start_time)
        total_time = st.session_state.end_time - st.session_state.start_time
        st.write(f"**User Name:** {st.session_state.user_name}")
        st.write(f"**Total Time:** {total_time}")

        # Convert timedelta to string before saving to leaderboard
        total_time_str = str(total_time)

        # Save results to leaderboard only if all 5 questions are completed correctly
        if st.session_state.questions_completed == 5:
            if st.button("Save to Leaderboard"):
                save_to_leaderboard(st.session_state.user_name, total_time_str, 'Beginner')
        else:
            st.warning("You must complete all 5 questions correctly to submit your result.")
    else:
        st.warning("You haven't completed all the questions yet.")
